# QA Test Cases - テストケース

## テストケース分類

1. [機能テスト](#1-機能テスト)
   - 1.1 [認証・認可](#11-認証認可)
   - 1.2 [サーバー管理](#12-サーバー管理)
   - 1.3 [電源管理](#13-電源管理)
   - 1.4 [ハートビート監視](#14-ハートビート監視)
   - 1.5 [エージェント機能](#15-エージェント機能)
2. [セキュリティテスト](#2-セキュリティテスト)
   - 2.1 [認証・認可のセキュリティ](#21-認証認可のセキュリティ)
   - 2.2 [CSRF 対策](#22-csrf対策)
   - 2.3 [アクセストークン管理](#23-アクセストークン管理)
   - 2.4 [HTTPS 強制](#24-https強制)
3. [非機能テスト](#3-非機能テスト)
   - 3.1 [可用性](#31-可用性)
   - 3.2 [ログ管理](#32-ログ管理)

---

## 1. 機能テスト

### 1.1 認証・認可

#### TC-AUTH-001: 正常なログイン

**目的**: 正しい ID/パスワードでログインできることを確認

**前提条件**:

- Manager が起動している
- 環境変数に有効なユーザー ID/パスワードが設定されている
- ユーザーは未認証状態

**テスト手順**:

1. ログイン画面 (`/login`) にアクセス
2. 正しい ID とパスワードを入力
3. ログインボタンをクリック

**期待結果**:

- サーバー管理画面 (`/servers`) にリダイレクトされる
- セッション Cookie が発行される
  - Name: `session_id`
  - HttpOnly: `true`
  - Secure: `true`
  - SameSite: `Strict`
- API ログが記録される

---

#### TC-AUTH-002: 不正なパスワードでのログイン失敗

**目的**: 不正なパスワードでログインが拒否されることを確認

**前提条件**:

- Manager が起動している
- ユーザーは未認証状態

**テスト手順**:

1. ログイン画面 (`/login`) にアクセス
2. 正しい ID と誤ったパスワードを入力
3. ログインボタンをクリック

**期待結果**:

- エラーメッセージが表示される
- ログイン画面に留まる
- セッション Cookie は発行されない
- ログイン失敗回数がカウントされる

---

#### TC-AUTH-003: ログイン試行回数制限（5 回失敗）

**目的**: 5 回ログインに失敗した場合、IP アドレス単位で 10 分間ブロックされることを確認

**前提条件**:

- Manager が起動している
- 同一 IP アドレスから接続

**テスト手順**:

1. 誤ったパスワードで 5 回連続ログインを試行
2. 6 回目のログインを試行（正しいパスワードでも）

**期待結果**:

- 5 回失敗後、ブロック中であることを示すメッセージが表示される
- 正しいパスワードでもログインできない
- 10 分間経過後、再度ログイン可能になる

---

#### TC-AUTH-004: セッションの有効期限

**目的**: セッションの有効期限が切れた後、未認証状態になることを確認

**前提条件**:

- ユーザーがログイン済み
- セッション有効期限が設定されている（環境変数）

**テスト手順**:

1. ログインする
2. セッション有効期限まで待機
3. 認証が必要なページにアクセス

**期待結果**:

- ログイン画面にリダイレクトされる
- 既存のセッションは無効化される

---

#### TC-AUTH-005: 認証済みユーザーのログイン画面アクセス

**目的**: すでに認証済みのユーザーがログイン画面にアクセスした場合、サーバー管理画面にリダイレクトされることを確認

**前提条件**:

- ユーザーがログイン済み
- 有効なセッション Cookie を保持

**テスト手順**:

1. ログイン画面 (`/login`) にアクセス

**期待結果**:

- サーバー管理画面 (`/servers`) に自動的にリダイレクトされる
- ログインフォームは表示されない

---

#### TC-AUTH-006: ログアウト

**目的**: ログアウトが正常に実行されることを確認

**前提条件**:

- ユーザーがログイン済み

**テスト手順**:

1. ヘッダーの人型アイコンをクリック
2. ドロップダウンメニューから「ログアウト」をクリック

**期待結果**:

- ログイン画面にリダイレクトされる
- セッション Cookie が削除される
- 以降、認証が必要なページにアクセスできない

---

### 1.2 サーバー管理

#### TC-SERVER-001: サーバー一覧表示

**目的**: 管理下にあるサーバーの一覧が正しく表示されることを確認

**前提条件**:

- ユーザーがログイン済み
- データベースに 1 台以上のサーバーが登録されている

**テスト手順**:

1. サーバー管理画面 (`/servers`) にアクセス

**期待結果**:

- 登録されている全サーバーが一覧表示される
- 各サーバーについて以下の情報が表示される:
  - サーバー名
  - サーバー ID（UUID）
  - 電源ステータス（ON/OFF）
  - カレントステータス
  - 電源ボタン（ON/OFF に応じた表示）

---

#### TC-SERVER-002: サーバーの追加（正常系）

**目的**: サーバーを正常に追加できることを確認

**前提条件**:

- ユーザーがログイン済み

**テスト手順**:

1. サーバー管理画面で「追加」ボタンをクリック
2. モーダルで以下を入力:
   - サーバー名: `TestServer`
   - MAC アドレス: `00:11:22:33:44:55`
   - ハートビート間隔: `10` (秒)
3. 保存ボタンをクリック
4. アクセストークンが表示される
5. 確認ボタンをクリック

**期待結果**:

- モーダルが閉じる
- サーバー一覧に新しいサーバーが追加される
- スナックバーで成功メッセージが表示される
- データベースにサーバー情報が保存される:
  - 電源ステータス: `OFF`
  - 前回ハートビートステータス: `Stopping`
  - 現在ハートビートステータス: `None`
- アクセストークンがハッシュ化されて保存される

---

#### TC-SERVER-003: サーバー追加のバリデーション（サーバー名）

**目的**: サーバー名のバリデーションが正しく機能することを確認

**前提条件**:

- ユーザーがログイン済み

**テスト手順**:

1. サーバー追加モーダルを開く
2. サーバー名を空欄にする

**期待結果**:

- リアルタイムでエラーメッセージが表示される
- 保存ボタンが無効化される

---

#### TC-SERVER-004: サーバー追加のバリデーション（MAC アドレス）

**目的**: MAC アドレスのバリデーションが正しく機能することを確認

**前提条件**:

- ユーザーがログイン済み

**テスト手順**:

1. サーバー追加モーダルを開く
2. 以下の不正な MAC アドレスを入力:
   - ケース 1: `invalid-mac`
   - ケース 2: `00:11:22:33:44`（短すぎる）
   - ケース 3: `00-11-22-33-44-55`（区切り文字が異なる）

**期待結果**:

- 各ケースでリアルタイムにエラーメッセージが表示される
- 正規表現 `/^[0-9A-Fa-f]{2}(:[0-9A-Fa-f]{2}){5}$/` に一致しない場合はエラー
- 保存ボタンが無効化される

---

#### TC-SERVER-005: サーバー追加のバリデーション（ハートビート間隔）

**目的**: ハートビート間隔のバリデーションが正しく機能することを確認

**前提条件**:

- ユーザーがログイン済み

**テスト手順**:

1. サーバー追加モーダルを開く
2. 以下の不正なハートビート間隔で保存を試みる:
   - ケース 1: `4`（範囲外：小さすぎる）
   - ケース 2: `61`（範囲外：大きすぎる）
   - ケース 3: `abc`（数値でない）

**期待結果**:

- 各ケースでエラーメッセージが表示される
- 5 ～ 60 秒の範囲外の値は拒否される
- サーバーは登録されない

---

#### TC-SERVER-006: サーバー詳細表示

**目的**: サーバー詳細画面で正しい情報が表示されることを確認

**前提条件**:

- ユーザーがログイン済み
- サーバーが 1 台以上登録されている

**テスト手順**:

1. サーバー一覧画面でサーバー名をクリック

**期待結果**:

- サーバー詳細画面 (`/servers/{id}`) に遷移する
- 以下の情報が表示される:
  - サーバー名
  - サーバー ID（UUID）
  - 電源ステータス
  - MAC アドレス
  - ハートビート間隔
  - 電源ボタン
  - 編集ボタン
  - アクセストークンローテーションボタン
  - 削除ボタン

---

#### TC-SERVER-007: サーバーの編集

**目的**: サーバー情報を正常に編集できることを確認

**前提条件**:

- ユーザーがログイン済み
- サーバーが登録されている

**テスト手順**:

1. サーバー詳細画面で「編集」ボタンをクリック
2. サーバー名を変更（例: `TestServer` → `UpdatedServer`）
3. 保存ボタンをクリック

**期待結果**:

- 詳細画面が更新される
- 変更内容が反映される
- スナックバーで成功メッセージが表示される
- データベースが更新される

---

#### TC-SERVER-008: アクセストークンのローテーション

**目的**: アクセストークンのローテーションが正常に実行されることを確認

**前提条件**:

- ユーザーがログイン済み
- サーバーが登録されている
- 既存のアクセストークンが存在する

**テスト手順**:

1. サーバー詳細画面で「アクセストークンのローテーション」ボタンをクリック
2. 確認モーダルで「はい」を選択
3. 新しいアクセストークンを確認
4. 確認ボタンをクリック

**期待結果**:

- 新しいアクセストークンが表示される（32 文字の大小英数字）
- 既存のアクセストークンは無効化される
- データベース上のトークンハッシュが更新される
- モーダルが閉じる
- スナックバーで成功メッセージが表示される

---

#### TC-SERVER-009: サーバーの削除

**目的**: サーバーを正常に削除できることを確認

**前提条件**:

- ユーザーがログイン済み
- サーバーが登録されている

**テスト手順**:

1. サーバー詳細画面で「削除」ボタンをクリック
2. 確認モーダルで「はい」を選択

**期待結果**:

- モーダルが閉じる
- サーバー一覧画面にリダイレクトされる
- 削除したサーバーが一覧から消える
- スナックバーで成功メッセージが表示される
- データベースから物理削除される
- 関連するアクセストークンも削除される

---

#### TC-SERVER-010: サーバー削除のキャンセル

**目的**: サーバー削除をキャンセルできることを確認

**前提条件**:

- ユーザーがログイン済み
- サーバーが登録されている

**テスト手順**:

1. サーバー詳細画面で「削除」ボタンをクリック
2. 確認モーダルで「いいえ」を選択

**期待結果**:

- モーダルが閉じる
- サーバーは削除されない
- 詳細画面に留まる

---

### 1.3 電源管理

#### TC-POWER-001: サーバーの電源起動（WoL）

**目的**: Wake-on-LAN による電源起動が正常に実行されることを確認

**前提条件**:

- ユーザーがログイン済み
- 電源 OFF のサーバーが登録されている
- サーバーの WoL が有効化されている
- Manager とサーバーが同一ネットワーク内にある

**テスト手順**:

1. サーバー一覧画面で電源 OFF のサーバーの「ON」ボタンをクリック

**期待結果**:

- スナックバーで起動開始メッセージが表示される
- カレントステータスが`Starting`になる
- WoL マジックパケットがサーバーの MAC アドレス宛に送信される
- データベースの電源ステータスが`ON`に更新される
- `last_power_changed_at`が更新される

---

#### TC-POWER-002: サーバーの電源停止

**目的**: サーバーの電源停止が正常に実行されることを確認

**前提条件**:

- ユーザーがログイン済み
- 電源 ON のサーバーが登録されている
- エージェントが稼働中

**テスト手順**:

1. サーバー一覧画面で電源 ON のサーバーの「OFF」ボタンをクリック

**期待結果**:

- スナックバーで停止開始メッセージが表示される
- カレントステータスが`Stopping`になる
- データベースの電源ステータスが`OFF`に更新される
- `last_power_changed_at`が更新される
- エージェントが次のハートビートでマニフェストを取得し、シャットダウンを開始する

---

#### TC-POWER-003: 電源ステータス変更のブロック（Applying 中）

**目的**: Applying 状態の間は電源ステータスを変更できないことを確認

**前提条件**:

- ユーザーがログイン済み
- サーバーが登録されている

**テスト手順**:

1. 電源ステータスを変更する
2. 次のハートビート更新前に再度電源ボタンをクリック

**期待結果**:

- 電源ボタンが無効化されている、またはエラーメッセージが表示される
- 電源ステータスは変更されない

---

#### TC-POWER-004: 電源ステータス変更のブロック（Starting 中）

**目的**: Starting 状態（電源起動中）は電源ステータスを変更できないことを確認

**前提条件**:

- サーバーが`Starting`状態

**テスト手順**:

1. 電源ボタンをクリック

**期待結果**:

- 電源ボタンが無効化されている、またはエラーメッセージが表示される
- 電源ステータスは変更されない

---

#### TC-POWER-005: 電源ステータス変更のブロック（Stopping 中）

**目的**: Stopping 状態（電源停止中）は電源ステータスを変更できないことを確認

**前提条件**:

- サーバーが`Stopping`状態

**テスト手順**:

1. 電源ボタンをクリック

**期待結果**:

- 電源ボタンが無効化されている、またはエラーメッセージが表示される
- 電源ステータスは変更されない

---

### 1.4 ハートビート監視

#### TC-HEARTBEAT-001: 初回ハートビート（Launched）

**目的**: エージェント起動直後のハートビートが正しく処理されることを確認

**前提条件**:

- サーバーが登録されている
- エージェントが停止している

**テスト手順**:

1. エージェントを起動する
2. 初回ハートビートが送信される

**期待結果**:

- ハートビートステータスが`Launched`になる
- データベースの`heartbeat_status`が更新される
- `last_heartbeat_at`が更新される
- API ログに記録される

---

#### TC-HEARTBEAT-002: 正常稼働中のハートビート（ON）

**目的**: 正常稼働中のハートビートが正しく処理されることを確認

**前提条件**:

- サーバーが登録されている
- 電源ステータスが`ON`
- エージェントが稼働中

**テスト手順**:

1. ハートビート間隔ごとにハートビートが送信される

**期待結果**:

- ハートビートステータスが`ON`になる
- カレントステータスが`ON`になる
- `last_heartbeat_at`が定期的に更新される

---

#### TC-HEARTBEAT-003: 停止処理中のハートビート（Stopping）

**目的**: 停止処理中のハートビートが正しく処理されることを確認

**前提条件**:

- 電源ステータスが`OFF`
- エージェントがシャットダウン処理を開始している

**テスト手順**:

1. シャットダウン処理中もハートビートが送信される

**期待結果**:

- ハートビートステータスが`Stopping`になる
- カレントステータスが`Stopping`になる
- `last_heartbeat_at`が更新される
- シャットダウン完了までハートビートが継続する

---

#### TC-HEARTBEAT-004: ハートビート途絶（Lost）

**目的**: ハートビートが途絶えた場合に Lost 状態になることを確認

**前提条件**:

- サーバーが`ON`状態で稼働中
- ハートビート間隔が 10 秒

**テスト手順**:

1. エージェントを強制停止または通信を遮断
2. ハートビート間隔 × 3（30 秒）待機

**期待結果**:

- カレントステータスが`Lost`になる
- ユーザーに通知が表示される
- ハートビートステータスが`None`になる
- `None`が連続して報告されることはない

---

#### TC-HEARTBEAT-005: SyncedON（手動起動の検出）

**目的**: 電源が手動で起動された場合、自動的に電源ステータスが ON に変更されることを確認

**前提条件**:

- 電源ステータスが`OFF`
- 前回ハートビートステータスが`None`

**テスト手順**:

1. サーバーの電源を手動で起動
2. エージェントが起動して`Launched`ハートビートを送信

**期待結果**:

- カレントステータスが`SyncedON`になる
- 電源ステータスが自動的に`ON`に変更される
- ユーザーに通知が表示される
- 表記上は`ON`と表示される

---

#### TC-HEARTBEAT-006: SyncedOFF（手動停止の検出）

**目的**: ハートビートが 5 分以上途絶えた場合、自動的に電源ステータスが OFF に変更されることを確認

**前提条件**:

- 電源ステータスが`ON`
- ハートビートステータスが`None`

**テスト手順**:

1. ハートビートが途絶えてから 5 分以上待機

**期待結果**:

- カレントステータスが`SyncedOFF`になる
- 電源ステータスが自動的に`OFF`に変更される
- ユーザーに通知が表示される
- 表記上は`OFF`と表示される

---

#### TC-HEARTBEAT-007: Starting → 5 分経過で SyncedOFF

**目的**: 電源起動処理が 5 分以上完了しない場合、SyncedOFF に移行することを確認

**前提条件**:

- 電源ステータスが`ON`
- 前回ハートビートステータスが`Stopping`
- カレントステータスが`Starting`

**テスト手順**:

1. WoL 送信後、サーバーが起動しない状態で 5 分待機

**期待結果**:

- カレントステータスが`SyncedOFF`になる
- 電源ステータスが自動的に`OFF`に変更される
- ユーザーに起動失敗の通知が表示される

---

#### TC-HEARTBEAT-008: Warning 状態（Launched 連続）

**目的**: Launched が 2 連続で報告された場合、Warning 状態になることを確認

**前提条件**:

- 電源ステータスが`ON`
- 前回ハートビートステータスが`Launched`

**テスト手順**:

1. エージェントを再起動して再度`Launched`を送信

**期待結果**:

- カレントステータスが`Warning`になる
- ユーザーに警告通知が表示される
- エージェントが再起動を繰り返している可能性を示す

---

#### TC-HEARTBEAT-009: Warning 状態（停止中の再起動）

**目的**: 電源停止中にエージェントが再起動した場合、Warning 状態になることを確認

**前提条件**:

- 電源ステータスが`OFF`
- 前回ハートビートステータスが`ON`または`Stopping`

**テスト手順**:

1. シャットダウン処理中にエージェントを再起動
2. `Launched`ハートビートを送信

**期待結果**:

- カレントステータスが`Warning`になる
- ユーザーに警告通知が表示される

---

### 1.5 エージェント機能

#### TC-AGENT-001: エージェントの初期設定（init）

**目的**: `komo-agent init`で初期設定が正常に実行されることを確認

**前提条件**:

- エージェントがインストールされている
- 設定ファイルが存在しない
- root 権限で実行

**テスト手順**:

1. `sudo komo-agent init`を実行
2. 対話形式で以下を入力:
   - マネージャー URL: `https://manager.example.com`
   - アクセストークン: `abcdefghijklmnopqrstuvwxyz123456`

**期待結果**:

- `/etc/komoriuta/config.json`が作成される
- 設定内容:
  - `enabled`: `false`
  - `managerURL`: 入力した URL
  - `accessToken`: 入力したトークン
  - `logGeneration`: `7`（デフォルト）
  - `disabledFileLog`: `false`（デフォルト）
- ログが記録される

---

#### TC-AGENT-002: init のバリデーション（URL）

**目的**: マネージャー URL のバリデーションが正しく機能することを確認

**前提条件**:

- root 権限で実行

**テスト手順**:

1. `sudo komo-agent init`を実行
2. 不正な URL を入力:
   - ケース 1: `invalid-url`
   - ケース 2: `http://remote.example.com`（localhost 以外で http スキーム）

**期待結果**:

- エラーメッセージが表示される
- 設定ファイルは作成されない
- localhost でない場合は https スキームが必須

---

#### TC-AGENT-003: init のバリデーション（アクセストークン）

**目的**: アクセストークンのバリデーションが正しく機能することを確認

**前提条件**:

- root 権限で実行

**テスト手順**:

1. `sudo komo-agent init`を実行
2. 不正なアクセストークンを入力:
   - ケース 1: `short`（32 文字未満）
   - ケース 2: `abcdefghijklmnopqrstuvwxyz1234567`（33 文字）
   - ケース 3: `abcdefghijklmnopqrstuvwxyz12345!`（記号を含む）

**期待結果**:

- エラーメッセージが表示される
- 32 文字の大小英数字であることが必須
- 設定ファイルは作成されない

---

#### TC-AGENT-004: エージェントの有効化（enable）

**目的**: `komo-agent enable`でエージェントが有効化されることを確認

**前提条件**:

- 設定ファイルが存在する
- `enabled`が`false`
- root 権限で実行

**テスト手順**:

1. `sudo komo-agent enable`を実行

**期待結果**:

- 設定ファイルの`enabled`が`true`に更新される
- `komolet`に開始シグナルが送信される
- `komolet`がハートビートの送信を開始する

---

#### TC-AGENT-005: エージェントの無効化（disable）

**目的**: `komo-agent disable`でエージェントが無効化されることを確認

**前提条件**:

- 設定ファイルが存在する
- `enabled`が`true`
- `komolet`が稼働中
- root 権限で実行

**テスト手順**:

1. `sudo komo-agent disable`を実行

**期待結果**:

- 設定ファイルの`enabled`が`false`に更新される
- `komolet`に停止シグナルが送信される
- `komolet`プロセスが終了する
- ハートビートの送信が停止する

---

#### TC-AGENT-006: 設定の変更（set managerUrl）

**目的**: `komo-agent set managerUrl`でマネージャー URL を変更できることを確認

**前提条件**:

- 設定ファイルが存在する
- root 権限で実行

**テスト手順**:

1. `sudo komo-agent set managerUrl https://new-manager.example.com`を実行

**期待結果**:

- 設定ファイルの`managerURL`が更新される
- ログが記録される

---

#### TC-AGENT-007: 設定の変更（set accessToken）

**目的**: `komo-agent set accessToken`でアクセストークンを変更できることを確認

**前提条件**:

- 設定ファイルが存在する
- root 権限で実行

**テスト手順**:

1. `sudo komo-agent set accessToken`を実行
2. 対話形式で新しいトークンを入力

**期待結果**:

- 入力したトークンが画面に表示されない
- 設定ファイルの`accessToken`が更新される
- ログが記録される（トークンはマスクされる）

---

#### TC-AGENT-008: 設定の変更（set logGeneration）

**目的**: `komo-agent set logGeneration`でログ世代数を変更できることを確認

**前提条件**:

- 設定ファイルが存在する
- root 権限で実行

**テスト手順**:

1. `sudo komo-agent set logGeneration 14`を実行

**期待結果**:

- 設定ファイルの`logGeneration`が更新される
- ログが記録される

---

#### TC-AGENT-009: 設定の変更（set disabledFileLog）

**目的**: `komo-agent set disabledFileLog`でファイル出力の有効/無効を変更できることを確認

**前提条件**:

- 設定ファイルが存在する
- root 権限で実行

**テスト手順**:

1. `sudo komo-agent set disabledFileLog true`を実行
2. `sudo komo-agent set disabledFileLog false`を実行

**期待結果**:

- 設定ファイルの`disabledFileLog`が更新される
- ログが記録される

---

#### TC-AGENT-010: 設定の再読み込み（reload）

**目的**: `komo-agent reload`で設定が再読み込みされることを確認

**前提条件**:

- `komolet`が稼働中
- root 権限で実行

**テスト手順**:

1. 設定ファイルを手動で変更
2. `sudo komo-agent reload`を実行

**期待結果**:

- `komolet`に再読み込みシグナルが送信される
- `komolet`が設定ファイルを再読み込みする
- 新しい設定が適用される

---

#### TC-AGENT-011: ステータス確認（status）

**目的**: `komo-agent status`で現在の状態が表示されることを確認

**前提条件**:

- 設定ファイルが存在する

**テスト手順**:

1. `komo-agent status`を実行（sudo 不要）

**期待結果**:

- エージェントの稼働状況が表示される（enabled/disabled）
- マネージャーの URL が表示される
- root 権限は不要

---

#### TC-AGENT-012: komolet のハートビート送信（Launched）

**目的**: komolet 起動直後に Launched ハートビートが送信されることを確認

**前提条件**:

- エージェントが有効化されている
- マネージャーと通信可能
- マニフェストの電源ステータスが`ON`

**テスト手順**:

1. `komolet`を起動
2. 初回ハートビートを確認

**期待結果**:

- ハートビートステータス`Launched`で送信される
- ログに記録される

---

#### TC-AGENT-013: komolet のハートビート送信（ON）

**目的**: 正常稼働中に ON ハートビートが送信されることを確認

**前提条件**:

- エージェントが稼働中
- マネージャーと通信可能
- マニフェストの電源ステータスが`ON`
- 初回ハートビート送信済み

**テスト手順**:

1. ハートビート間隔待機
2. 2 回目以降のハートビートを確認

**期待結果**:

- ハートビートステータス`ON`で送信される
- ハートビート間隔ごとに定期的に送信される
- ログに記録される

---

#### TC-AGENT-014: komolet のハートビート送信（Stopping）とシャットダウン実行

**目的**: komolet が電源 OFF 命令を受けて Stopping ハートビートを送信し、シャットダウンを実行することを確認

**前提条件**:

- エージェントが稼働中
- マニフェストの電源ステータスが`ON`

**テスト手順**:

1. マネージャーから電源ステータスを`OFF`に変更
2. 次のハートビートでマニフェストを取得

**期待結果**:

- マニフェストの電源ステータスが`OFF`
- ハートビートステータス`Stopping`で送信される
- シャットダウン処理を開始
- シャットダウン処理が重複して実行されない
- OS の shutdown コマンドが実行される
- ログに記録される

---

#### TC-AGENT-015: komolet の通信エラーハンドリング

**目的**: マネージャーとの通信に失敗した場合、リトライが実行されることを確認

**前提条件**:

- エージェントが稼働中
- マネージャーが一時的に停止またはネットワーク障害

**テスト手順**:

1. マネージャーを停止またはネットワークを遮断
2. ハートビート送信タイミングを待機

**期待結果**:

- 2 回までリトライが実行される
- 3 回失敗後、エラーログが出力される
- 次のハートビート間隔まで待機する
- komolet プロセスは終了しない

---

#### TC-AGENT-016: root 権限チェック

**目的**: help/version 以外のコマンドは root 権限が必要なことを確認

**前提条件**:

- 一般ユーザーで実行

**テスト手順**:

1. `komo-agent init`を一般ユーザーで実行
2. `komo-agent enable`を一般ユーザーで実行

**期待結果**:

- エラーメッセージが表示される
- 処理は実行されない
- `help`と`version`コマンドは実行可能

---

## 2. セキュリティテスト

### 2.1 認証・認可のセキュリティ

#### TC-SEC-AUTH-001: パスワードのハッシュ化（komo-manager）

**目的**: komo-manager のユーザーパスワードが scrypt でハッシュ化されて保存されることを確認

**前提条件**:

- 環境変数にパスワードが設定されている

**テスト手順**:

1. 環境変数のパスワード設定を確認

**期待結果**:

- パスワードは scrypt でハッシュ化された文字列として保存される
- 平文のパスワードは保存されない

---

#### TC-SEC-AUTH-002: セッション Cookie の属性

**目的**: セッション Cookie が適切なセキュリティ属性を持つことを確認

**前提条件**:

- ユーザーがログイン済み

**テスト手順**:

1. ログイン後、Cookie を確認

**期待結果**:

- Name: `session_id`
- HttpOnly: `true`（JavaScript からアクセス不可）
- Secure: `true`（HTTPS 通信のみ）
- SameSite: `Strict`（クロスサイトリクエスト防止）
- Path: `/`
- MaxAge: 環境変数で設定された有効期限

---

#### TC-SEC-AUTH-003: セッション ID の推測不可能性

**目的**: セッション ID が推測不可能なランダム値であることを確認

**前提条件**:

- なし

**テスト手順**:

1. 複数回ログインしてセッション ID を取得

**期待結果**:

- セッション ID は UUIDv4 形式
- 各セッション ID がランダムで一意
- 連続性や予測可能なパターンが存在しない

---

#### TC-SEC-AUTH-004: 未認証アクセスの拒否

**目的**: 未認証ユーザーが保護されたページにアクセスできないことを確認

**前提条件**:

- ユーザーが未認証状態

**テスト手順**:

1. `/servers`に直接アクセス
2. `/servers/{id}`に直接アクセス

**期待結果**:

- ログイン画面にリダイレクトされる
- 保護されたコンテンツは表示されない

---

#### TC-SEC-AUTH-005: セッションハイジャック対策

**目的**: 他のユーザーのセッション ID を使用してもアクセスできないことを確認

**前提条件**:

- 2 つの異なるブラウザ/環境

**テスト手順**:

1. ブラウザ A でログイン
2. ブラウザ B でブラウザ A のセッション ID を Cookie に設定

**期待結果**:

- ブラウザ B ではアクセスできない、またはセキュリティ警告が表示される
- IP アドレスや User-Agent 等の検証が行われる（実装に依存）

---

### 2.2 CSRF 対策

#### TC-SEC-CSRF-001: CORS 設定（同一オリジン）

**目的**: 同一オリジンからのリクエストのみ許可されることを確認

**前提条件**:

- Manager が稼働中

**テスト手順**:

1. 同一オリジンから API リクエストを送信

**期待結果**:

- リクエストが正常に処理される
- CORS エラーが発生しない

---

#### TC-SEC-CSRF-002: CORS 設定（異なるオリジン）

**目的**: 異なるオリジンからのリクエストが拒否されることを確認

**前提条件**:

- Manager が稼働中

**テスト手順**:

1. 異なるオリジン（例: `http://malicious.com`）から API リクエストを送信

**期待結果**:

- CORS エラーが発生する
- リクエストが拒否される
- プリフライトリクエストが失敗する

---

#### TC-SEC-CSRF-003: Preflight Request

**目的**: すべてのリクエストで Preflight リクエストが発行されることを確認

**前提条件**:

- Manager が稼働中

**テスト手順**:

1. POST/PUT/DELETE リクエストを送信
2. ブラウザの開発者ツールでネットワークを確認

**期待結果**:

- OPTIONS メソッドの Preflight リクエストが先に送信される
- Preflight が成功後、実際のリクエストが送信される

---

#### TC-SEC-CSRF-004: SameSite Cookie 属性

**目的**: Cookie の SameSite 属性が Strict に設定されていることを確認

**前提条件**:

- ユーザーがログイン済み

**テスト手順**:

1. ログイン後、Cookie の属性を確認
2. 外部サイトからのリクエストを試行

**期待結果**:

- SameSite 属性が`Strict`
- クロスサイトリクエストで Cookie が送信されない

---

### 2.3 アクセストークン管理

#### TC-SEC-TOKEN-001: アクセストークンの生成

**目的**: アクセストークンが安全に生成されることを確認

**前提条件**:

- サーバーを新規登録

**テスト手順**:

1. サーバーを追加
2. 表示されたアクセストークンを確認

**期待結果**:

- 32 文字の大小英数字
- ランダムで推測不可能
- 各トークンが一意

---

#### TC-SEC-TOKEN-002: アクセストークンのハッシュ化保存

**目的**: アクセストークンが scrypt でハッシュ化されて DB 保存されることを確認

**前提条件**:

- サーバーが登録されている

**テスト手順**:

1. データベースの`access_tokens`テーブルを確認

**期待結果**:

- `token_hash`フィールドに scrypt ハッシュ値が保存される
- 平文のトークンは保存されない

---

#### TC-SEC-TOKEN-003: アクセストークン認証（正常）

**目的**: 正しいアクセストークンでエージェントが認証されることを確認

**前提条件**:

- サーバーが登録されている
- 有効なアクセストークンを保持

**テスト手順**:

1. エージェントからハートビートを送信
2. リクエストヘッダー: `Authorization: Bearer {valid_token}`

**期待結果**:

- 認証が成功する
- ハートビートが正常に処理される

---

#### TC-SEC-TOKEN-004: アクセストークン認証（不正なトークン）

**目的**: 不正なアクセストークンで認証が拒否されることを確認

**前提条件**:

- Manager が稼働中

**テスト手順**:

1. エージェントから不正なトークンでハートビートを送信
2. リクエストヘッダー: `Authorization: Bearer invalid_token`

**期待結果**:

- 401 Unauthorized エラーが返される
- リクエストが拒否される
- エラーログが記録される

---

#### TC-SEC-TOKEN-005: アクセストークンローテーション後の旧トークン無効化

**目的**: ローテーション後、旧トークンが無効化されることを確認

**前提条件**:

- サーバーが登録されている
- アクセストークンが発行済み

**テスト手順**:

1. 旧トークンを記録
2. アクセストークンをローテーション
3. 旧トークンでリクエスト送信

**期待結果**:

- 旧トークンでの認証が失敗する
- 401 Unauthorized エラーが返される
- 新トークンのみが有効

---

#### TC-SEC-TOKEN-006: アクセストークンの有効期限

**目的**: アクセストークンの有効期限が正しく機能することを確認

**前提条件**:

- 環境変数で有効期限を設定（例: 90 日）

**テスト手順**:

1. アクセストークンを発行
2. 有効期限が経過するまで待機（またはテスト用に短い期限を設定）
3. 有効期限切れのトークンでリクエスト送信

**期待結果**:

- 有効期限内はリクエストが成功する
- 有効期限切れ後は 401 エラーが返される
- 有効期限 0 秒の場合は無期限

---

#### TC-SEC-TOKEN-007: Bearer Token 形式の検証

**目的**: Authorization ヘッダーが正しい Bearer Token 形式であることを確認

**前提条件**:

- Manager が稼働中

**テスト手順**:

1. 不正な形式でリクエスト送信:
   - ケース 1: `Authorization: {token}`（Bearer なし）
   - ケース 2: `Authorization: Basic {token}`（異なるスキーム）
   - ケース 3: ヘッダーなし

**期待結果**:

- 各ケースで 401 エラーが返される
- `Bearer `プレフィックスが必須

---

### 2.4 HTTPS 強制

#### TC-SEC-HTTPS-001: localhost での HTTP 許可

**目的**: localhost からの HTTP アクセスが許可されることを確認

**前提条件**:

- Manager が localhost で稼働中

**テスト手順**:

1. `http://localhost:PORT`にアクセス

**期待結果**:

- HTTP でアクセス可能
- 正常に動作する

---

#### TC-SEC-HTTPS-002: リモートアクセスでの HTTP 拒否（Manager）

**目的**: Manager が localhost 以外からの HTTP アクセスを拒否することを確認

**前提条件**:

- Manager がネットワーク上で稼働中

**テスト手順**:

1. `http://remote-manager.example.com`に HTTP でアクセス

**期待結果**:

- HTTP 通信が拒否される
- エラーメッセージが返される

---

#### TC-SEC-HTTPS-003: リモートアクセスでの HTTP 拒否（Agent）

**目的**: エージェントが localhost 以外のマネージャーに HTTP で通信しようとした場合、エラーが返されることを確認

**前提条件**:

- エージェントの設定でマネージャー URL が`http://remote.example.com`

**テスト手順**:

1. `komo-agent enable`を実行

**期待結果**:

- エラーメッセージが表示される
- HTTPS で通信するよう促される
- 通信が開始されない

---

#### TC-SEC-HTTPS-004: TLS/SSL 証明書の検証

**目的**: 不正な証明書や self-signed 証明書が拒否されることを確認

**前提条件**:

- HTTPS 環境

**テスト手順**:

1. 無効な証明書を持つサーバーにアクセス

**期待結果**:

- 証明書エラーが表示される
- 接続が拒否される（ブラウザおよびエージェント）

---

## 3. 非機能テスト

### 3.1 可用性

#### TC-AVAIL-001: Manager の再起動時の挙動

**目的**: Manager 再起動後も正常に動作することを確認

**前提条件**:

- Manager が稼働中
- サーバーが登録されている
- エージェントが稼働中

**テスト手順**:

1. Manager を再起動
2. 再起動後、エージェントからハートビートを送信
3. UI にアクセス

**期待結果**:

- データベースの内容が保持される
- セッション情報は再起動後クリアされる（インメモリ）
- ログイン制限情報も再起動後クリアされる（インメモリ）
- エージェントのハートビートが正常に受信される
- カレントステータスが正しく算出される

---

### 3.2 ログ管理

#### TC-LOG-001: API ログの記録

**目的**: API リクエスト/レスポンスが正しくログに記録されることを確認

**前提条件**:

- Manager が稼働中
- ファイル出力が有効

**テスト手順**:

1. API リクエストを送信
2. `/var/log/komoriuta/komo-manager.log.jsonl`を確認

**期待結果**:

- JSON Lines 形式でログが記録される
- 各ログに以下が含まれる:
  - `level`: INFO/WARN/ERROR
  - `timestamp`: ISO 8601 形式
  - `type`: "api"
  - `procedure`: プロシージャ名
  - `ipAddress`: クライアント IP
  - `durationMs`: 処理時間
- 機密情報（パスワード、トークン）はマスクされる

---

#### TC-LOG-002: ハートビート監視ログの記録

**目的**: ハートビート監視のログが正しく記録されることを確認

**前提条件**:

- Manager が稼働中
- エージェントが稼働中

**テスト手順**:

1. ハートビートを送信
2. ログファイルを確認

**期待結果**:

- `type`: "heartbeat_watch"
- 以下の情報が記録される:
  - `serverID`, `serverUUID`, `serverName`
  - `powerStatus`
  - `previousHeartbeatStatus`
  - `heartbeatStatus`
  - `currentStatus`

---

#### TC-LOG-003: エラーログの記録

**目的**: エラーが正しくログに記録されることを確認

**前提条件**:

- Manager が稼働中

**テスト手順**:

1. 意図的にエラーを発生させる（例: 不正なリクエスト）
2. ログファイルを確認

**期待結果**:

- `level`: ERROR
- `type`: "error"
- `message`: エラーメッセージ
- `stackTrace`: スタックトレース（オプション）
- `context`: エラー発生時の追加情報（オプション）

---

#### TC-LOG-004: ログファイルの権限

**目的**: ログファイルが適切な権限で作成されることを確認

**前提条件**:

- Manager/Agent が稼働中

**テスト手順**:

1. ログファイルの権限を確認

**期待結果**:

- パーミッション: `600`
- 所有者のみが読み書き可能
- 他のユーザーはアクセス不可

---

#### TC-LOG-005: ログローテーション（Manager）

**目的**: Manager のログローテーションが正しく機能することを確認

**前提条件**:

- ファイル出力が有効
- logrotate が設定済み
- `LOG_ROTATION_GENERATIONS=7`

**テスト手順**:

1. 7 日分のログを生成
2. 8 日目のログを生成

**期待結果**:

- 日次でローテーションが実行される
- 最大 7 世代が保持される
- 8 日目に最古のログが削除される
- ローテーション後も新しいログが記録される

---

#### TC-LOG-006: ログローテーション（Agent）

**目的**: Agent のログローテーションが正しく機能することを確認

**前提条件**:

- ファイル出力が有効
- `logGeneration: 7`

**テスト手順**:

1. 7 日分のログを生成
2. 8 日目のログを生成

**期待結果**:

- 日次でローテーションが実行される
- 設定された世代数が保持される
- 最古のログが削除される

---

#### TC-LOG-007: ファイル出力の無効化（Manager）

**目的**: 環境変数でファイル出力を無効化できることを確認

**前提条件**:

- `DISABLE_FILE_LOG=true`

**テスト手順**:

1. Manager を起動
2. ログファイルの存在を確認

**期待結果**:

- ログファイルが作成されない
- 標準出力にはログが出力される

---

#### TC-LOG-008: ファイル出力の無効化（Agent）

**目的**: 設定ファイルでファイル出力を無効化できることを確認

**前提条件**:

- `disabledFileLog: true`

**テスト手順**:

1. komolet を起動
2. ログファイルの存在を確認

**期待結果**:

- ログファイルが作成されない
- 標準出力にはログが出力される

---

#### TC-LOG-009: 標準出力ログ

**目的**: 標準出力へのログ出力が常に有効であることを確認

**前提条件**:

- Manager/Agent が稼働中
- ファイル出力が無効

**テスト手順**:

1. コンテナ/プロセスの標準出力を確認

**期待結果**:

- JSON Lines 形式でログが出力される
- ファイル出力の有効/無効に関わらず標準出力される
- systemd や Podman 経由でログを確認可能

---

#### TC-LOG-010: komo-agent のコマンドログ

**目的**: komo-agent のコマンド実行がログに記録されることを確認

**前提条件**:

- なし

**テスト手順**:

1. `sudo komo-agent init`等のコマンドを実行
2. `/var/log/komoriuta/komo-agent.log.jsonl`を確認

**期待結果**:

- `command`: 実行されたコマンド名
- `args`: コマンド引数
- `message`: 実行結果メッセージ
- JSON Lines 形式で記録される

---

#### TC-LOG-011: komolet のシグナルログ

**目的**: komolet が受信したシグナルがログに記録されることを確認

**前提条件**:

- komolet が稼働中

**テスト手順**:

1. `komo-agent enable`でシグナル送信
2. ログファイルを確認

**期待結果**:

- `type`: "signal"
- `signal`: START/STOP/RELOAD
- ログに記録される

---

## 4. 統合テストシナリオ

### TC-INTEGRATION-001: 完全な電源管理フロー

**目的**: サーバー登録から電源 ON→OFF→ON の一連のフローを確認

**テスト手順**:

1. ユーザーがログイン
2. サーバーを追加
3. エージェントを設定・起動
4. 初回ハートビートを確認（Launched）
5. 電源を ON（既に ON のため、ステータス確認）
6. 電源を OFF に変更
7. シャットダウンを確認
8. 電源を ON に変更
9. WoL による起動を確認
10. 起動後のハートビートを確認

**期待結果**:

- 各ステップが正常に動作する
- ステータス遷移が正しい
- ログが適切に記録される

---

### TC-INTEGRATION-002: セキュリティフロー

**目的**: 認証・認可・トークン管理の全体フローを確認

**テスト手順**:

1. 未認証でアクセス試行 → 拒否
2. ログイン → セッション発行
3. サーバー追加 → アクセストークン発行
4. エージェントがトークンで認証
5. トークンローテーション
6. 旧トークンで認証失敗を確認
7. 新トークンで認証成功を確認
8. ログアウト → セッション無効化

**期待結果**:

- セキュリティ機構が全体として正しく機能する
- 各段階で適切な認証・認可が行われる

---

## 5. テスト実施ガイドライン

### 5.1 テスト環境

- **Manager 環境**:

  - OS: Linux（推奨: Arch Linux、Ubuntu、など）
  - Podman: 最新版
  - SQLite: 3.x
  - ネットワーク: 同一セグメント内での WoL 対応

- **Agent 環境**:
  - OS: Linux
  - systemd 対応
  - WoL 対応 BIOS/UEFI 設定
  - 管理者権限

### 5.2 テストデータ

- **テストユーザー**:

  - ID: `test_user`
  - パスワード: `Test1234!@#$`（scrypt ハッシュ化）

- **テストサーバー**:
  - 名前: `TestServer01`
  - MAC アドレス: `00:11:22:33:44:55`
  - ハートビート間隔: 10 秒

### 5.3 優先度

- **P0（Critical）**: システムの基本機能、セキュリティ

  - 認証・認可
  - 電源 ON/OFF
  - ハートビート監視
  - HTTPS 強制
  - アクセストークン管理

- **P1（High）**: 重要な機能

  - サーバー管理 CRUD
  - ステータス遷移
  - ログ記録
  - エラーハンドリング

- **P2（Medium）**: 補助機能
  - UI の使いやすさ
  - ログローテーション

### 5.4 自動化推奨テスト

以下のテストは自動化が推奨されます:

- 認証・認可の基本フロー
- API エンドポイントの正常系
- バリデーションテスト
- ステータス遷移の網羅テスト
- セキュリティテスト（CORS、HTTPS、トークン検証）

### 5.5 手動テスト推奨項目

以下は手動でのテストが推奨されます:

- UI/UX の確認
- エンドツーエンドの統合シナリオ
- 実機での WoL 動作確認
- 長期間稼働テスト

---

## 6. 完了基準

### 6.1 リリース基準

以下の条件をすべて満たす場合、リリース可能と判断します:

1. P0（Critical）テストケースが 100%合格
2. P1（High）テストケースが 95%以上合格
3. セキュリティテストがすべて合格
4. 既知の重大なバグがゼロ
5. ドキュメントが完備されている

### 6.2 テストカバレッジ目標

- コードカバレッジ: 80%以上
- 主要機能の E2E テスト: 100%
- セキュリティテスト: 100%
